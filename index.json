[{"categories":["default"],"content":"分享一些项目地址 基于websocket的聊天平台 本博客网站地址 wx小程序校园管理系统 前端代码 前端微信小程序 后端代码 后端api 基于El-ui的后台管理 基于vue，包含所有常见数据类型的后台管理系统 ","date":"2024-04-20","objectID":"http://localhost:1313/posts/my_project/:0:0","tags":null,"title":"项目地址","uri":"http://localhost:1313/posts/my_project/"},{"categories":["default"],"content":"DRF整理 ","date":"2024-04-18","objectID":"http://localhost:1313/posts/drf/:0:0","tags":null,"title":"Drf整合","uri":"http://localhost:1313/posts/drf/"},{"categories":["default"],"content":"1.认证组件 基本使用 单视图全方法应用 ​ 这个非常简单，直接看就能看懂，认证组件必须重写父类的authenticate方法。同时认证组件可以正常接收到请求对象，也就是请求中的所有内容，包括请求头和请求体，以及其它野数据，因此，在认证组件中进行校验逻辑，比如token是否有效等，如果通过校验，直接返回空值或者两个参数，这两个参数将会依次封装到此次请求的request对象的user和auth中。 class MineAuthentication(BaseAuthentication): def authenticate(self, request): token = request.query_params.get(\"token\") if not token: raise AuthenticationFailed({\"status\": 0, \"msg\": \"认证失败,没有登录\"}) user_object = models.User.objects.filter(token=token).first() if not user_object: raise AuthenticationFailed({\"status\": 0, \"msg\": \"token无效\"}) return user_object, token # request.user request.auth class User(APIView): authentication_classes = [MineAuthentication] def get(self,request): return Response(...) def post(self,request): return ... .... 单视图多方法应用 ​ 上述代码，可以在视图中的所有方法中应用对应的组件，但是当我们需要只针对某几个请求限制权限，应该如何做呢？ 这里可以使用闭包来完成这个需求，闭包的作用就是可以动态的调用一个函数，让这个返回我们想要的内容 def nb(cls, user_method): def inner(): obj = cls(user_method) return obj return inner 让我来解释一下这个函数，此函数将会接收两个，参数，然后最终返回一个inner ，而这个inner函数是在nb函数中进行声明的。因此，我们传入的cls 和method 将直接决定了这个函数的内容。 很显然，传入的cls可能是一个对象，那么他将会被实例化，同时传给构造方法的是user_method , 然后这个实例对象将是nb最终返回值。如果cls是一个函数，那么这个函数会被执行，并且函数结果作为nb返回值 那么我们可以自己写一个认证组件(它是一个类),在他的构造方法中，将会拿到user_method,此时将它进行封装，就可以在认证的方法中针对这个参数做不同的判断逻辑了 class My3Authentication(BaseAuthentication): def __init__(self, user_methods): self.user_methods = user_methods # 封装user_methods def authenticate(self, request): if request.method not in self.user_methods: # 如果请求方法不在对应的user_methods列表，直接跳过认证。 return .... def nb(cls, user_method): def inner(): obj = cls(user_method) return obj return inner class MyView(APIView): authentication_classes = [nb(My3Authentication, [\"GET\"])] # def get(self,request): return Response(...) 全局 # settings.py REST_FRAMEWORK = { \"DEFAULT_AUTHENTICATION_CLASSES\": [\"xxxxx\", ], # 全局应用认证组件 } ","date":"2024-04-18","objectID":"http://localhost:1313/posts/drf/:1:0","tags":null,"title":"Drf整合","uri":"http://localhost:1313/posts/drf/"},{"categories":["default"],"content":"2.权限组件 权限组件听起来和认证类似，但是他们的应用场景有一定的区分度 认证组件一般适用： 用户是否登录 权限组件一般就是更加细致的划分 管理员权限 必须是xxx地区用户 必须大于xxx年龄等 基本使用（和认证组件的使用方法类似），需要写一个认证组件类，且重写父类has_permission方法，具有权限则返回True，如果没有权限，则返回False class MinePermission(BasePermission): message = {\"status\": False, \"msg\": \"无权限访问\"} # 认证失败返回的内容 code = \"500\" def has_permission(self, request, view): if request.user.level == 1: # 管理员 return True return False # 返回权限访问字符串 class User(APIView): permission_classes = [xxxx,xxxx] 全局应用 # settings.py REST_FRAMEWORK = { \"DEFAULT_AUTHENTICATION_CLASSES\": [\"xxxxx\", ], # 全局应用认证组件 \"DEFAULT_PERMISSION_CLASSES\": [\"utils.permission.MinePermission\"], # 全局应用权限组件 } ","date":"2024-04-18","objectID":"http://localhost:1313/posts/drf/:2:0","tags":null,"title":"Drf整合","uri":"http://localhost:1313/posts/drf/"},{"categories":["default"],"content":"3.限流组件 限流，限制用户访问频率，例如：用户1分钟最多访问100次 或者 短信验证码一天每天可以发送50次， 防止盗刷。 对于匿名用户，使用用户IP作为唯一标识。 对于登录用户，使用用户ID或名称作为唯一标识。 用户访问记录可以记录在缓存中，因此可以配置redis pip install django-redis # settings.py CACHES = { \"default\": { \"BACKEND\": \"django_redis.cache.RedisCache\", \"LOCATION\": \"redis://127.0.0.1:6379\", \"OPTIONS\": { \"CLIENT_CLASS\": \"django_redis.client.DefaultClient\", \"PASSWORD\": \"qwe123\", } } } # views.py from rest_framework.views import APIView from rest_framework.response import Response from rest_framework import exceptions from rest_framework import status from rest_framework.throttling import SimpleRateThrottle from django.core.cache import cache as default_cache class ThrottledException(exceptions.APIException): status_code = status.HTTP_429_TOO_MANY_REQUESTS default_code = 'throttled' class MyRateThrottle(SimpleRateThrottle): cache = default_cache # 访问记录存放在django的缓存中（需设置缓存） scope = \"user\" # 构造缓存中的key cache_format = 'throttle_%(scope)s_%(ident)s' # 设置访问频率，例如：1分钟允许访问10次 # 其他：'s', 'sec', 'm', 'min', 'h', 'hour', 'd', 'day' THROTTLE_RATES = {\"user\": \"10/m\"} def get_cache_key(self, request, view): if request.user: ident = request.user.pk # 用户ID else: ident = self.get_ident(request) # 获取请求用户IP（去request中找请求头） # throttle_u # throttle_user_11.11.11.11ser_2 return self.cache_format % {'scope': self.scope, 'ident': ident} def throttle_failure(self): wait = self.wait() detail = { \"code\": 1005, \"data\": \"访问频率限制\", 'detail': \"需等待{}s才能访问\".format(int(wait)) } raise ThrottledException(detail) class OrderView(APIView): throttle_classes = [MyRateThrottle, ] def get(self, request): return Response({\"code\": 0, \"data\": \"数据...\"}) 让我来解释一下限流组件是如何工作的，他会维护一个列表，用户每次访问，都会将当时访问的时间按照队列的形式存入列表，同时它每次查询是否限流，会根据这个队列取规定时间内最近的几个，如果个数满了，那么接下来就会进行限制访问。 多个限流类 本质，每个限流的类中都有一个 allow_request 方法，此方法内部可以有三种情况： 返回True，表示当前限流类允许访问，继续执行后续的限流类。 返回False，表示当前限流类不允许访问，继续执行后续的限流类。所有的限流类执行完毕后，读取所有不允许的限流，并计算还需等待的时间。 抛出异常，表示当前限流类不允许访问，后续限流类不再执行。 全局配置 REST_FRAMEWORK = { \"DEFAULT_THROTTLE_CLASSES\":[\"xxx.xxx.xx.限流类\", ], \"DEFAULT_THROTTLE_RATES\": { \"user\": \"10/m\", \"xx\":\"100/h\" } } 关于限流源码 ","date":"2024-04-18","objectID":"http://localhost:1313/posts/drf/:3:0","tags":null,"title":"Drf整合","uri":"http://localhost:1313/posts/drf/"},{"categories":["default"],"content":"4.解析器 drf中可以通过request.data直接获取请求体数据，而这个数据是在drf中对其进行的封装 ","date":"2024-04-18","objectID":"http://localhost:1313/posts/drf/:4:0","tags":null,"title":"Drf整合","uri":"http://localhost:1313/posts/drf/"},{"categories":["default"],"content":"3.7.1 JSONParser （*） ","date":"2024-04-18","objectID":"http://localhost:1313/posts/drf/:4:1","tags":null,"title":"Drf整合","uri":"http://localhost:1313/posts/drf/"},{"categories":["default"],"content":"3.7.2 FormParser ","date":"2024-04-18","objectID":"http://localhost:1313/posts/drf/:4:2","tags":null,"title":"Drf整合","uri":"http://localhost:1313/posts/drf/"},{"categories":["default"],"content":"3.7.3 MultiPartParser（*） \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cform action=\"http://127.0.0.1:8000/test/\" method=\"post\" enctype=\"multipart/form-data\"\u003e \u003cinput type=\"text\" name=\"user\" /\u003e \u003cinput type=\"file\" name=\"img\"\u003e \u003cinput type=\"submit\" value=\"提交\"\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2024-04-18","objectID":"http://localhost:1313/posts/drf/:4:3","tags":null,"title":"Drf整合","uri":"http://localhost:1313/posts/drf/"},{"categories":["default"],"content":"3.7.4 FileUploadParser（*） 解析器可以设置多个，默认解析器： from rest_framework.views import APIView from rest_framework.response import Response from rest_framework.parsers import MultiPartParser, JSONParser, FormParser class UserView(APIView): def post(self, request): print(request.content_type) print(request.data) return Response(\"...\") ","date":"2024-04-18","objectID":"http://localhost:1313/posts/drf/:4:4","tags":null,"title":"Drf整合","uri":"http://localhost:1313/posts/drf/"},{"categories":["default"],"content":"5.序列化器 drf中提供序列化器，主要做两件事： 对请求数据进行校验类似于form表单校验 对数据库查询的对象进行序列化。 ","date":"2024-04-18","objectID":"http://localhost:1313/posts/drf/:5:0","tags":null,"title":"Drf整合","uri":"http://localhost:1313/posts/drf/"},{"categories":["default"],"content":"5.1 定义序列化器： serializer： ​ 下面是常见的字段 class IndexSerializers(serializers.Serializer): # x1 = serializers.CharField(source=\"title\") # x2 = serializers.CharField(source=\"number\") # 平凡的字段 id = serializers.IntegerField() real_name = serializers.CharField() # 时间字段 c_time = serializers.DateTimeField(format=\"%Y-%m-%d\") # 选择字段 gender = serializers.IntegerField() gender_text = serializers.CharField(source=\"get_gender_display\") # 如果遇到choice类型字段 gender_dict = serializers.SerializerMethodField() # 序列化器遇到这个字段会自动去寻找 get_字段名() 的方法，并将其返回值作为字段值。 # 自定义字段 test_field = serializers.SerializerMethodField() # 外键字段 depart_str = serializers.CharField(source=\"depart\") depart_id = serializers.IntegerField(source=\"depart.id\") depart_text = serializers.CharField(source=\"depart.title\") depart_xxxxx = serializers.SerializerMethodField() depart = DepartSerializers() # 多对多 MtM hobbies1 = serializers.SerializerMethodField() hobbies2 = HobbySerializers(many=True, source=\"hobbys\") # 因为有多条数据，别忘记many属性的true hobbys = HobbySerializers(many=True) def get_gender_dict(self, obj): # print(\"obj:\", obj) return { \"id\": obj.gender, \"text\": obj.get_gender_display(), } def get_test_field(self, obj): return (\"余天王自定义字段\") def get_depart_xxxxx(self, obj): # print(obj) return { \"id\": obj.depart.id, \"title\": obj.depart.title, \"number\": obj.depart.number, } def get_hobbies1(self, obj): print(1111) hobby_objects = obj.hobbys.all() return [{\"id\": x.id, \"text\": x.text} for x in hobby_objects] modelserializer 基于serializer ，但是它可以省略手写字段，或者尽可能少些字段。而且支持了一键保存 class IndexModelSerializers(serializers.ModelSerializer): class Meta: model = models.UserInfo # 根据模型类的字段类型生成对应的序列化器字段、 fields = \"__all__\" # 指定全部字段 # fields = [\"id\",\"title\"] # 指定某几个字段 # exclude = [\"title\"] # 排除某几个字段 ","date":"2024-04-18","objectID":"http://localhost:1313/posts/drf/:5:1","tags":null,"title":"Drf整合","uri":"http://localhost:1313/posts/drf/"},{"categories":["default"],"content":"5.2 钩子方法 class InfoSerializer(serializers.Serializer): title = serializers.CharField(required=True, max_length=20, min_length=6) order = serializers.IntegerField(required=False, max_value=100, min_value=10) level = serializers.ChoiceField(choices=[(1, \"高级\"), (2, \"中级\")]) # 正则 # email = serializers.EmailField() email = serializers.CharField(required=False, validators=[EmailValidator(message=\"邮箱格式错误！！！\")]) # EmailValidator 是django中提供的邮箱正则校验 more = serializers.CharField(required=False, validators=[RegexValidator(r\"\\d+\", message=\"格式错误\")]) code = serializers.CharField(required=False) # 钩子方法 def validate_code(self, value): print(\"code校验中...\") if len(value) \u003e 6: raise Exc.ValidationError(\"code字段长度不能大于6\") return value def validate(self, attrs): # raise Exc.ValidationError(\"整体校验失败\") return attrs 让我来解释一下，validate_xxxx 是针对某个字段进行校验，最后需要进行返回这个字段值，如果没有通过校验则返回校验异常，而被返回的值会被封装到self.validated_data 中。而validate是对于所有字段校验完毕后再来一次整体的校验。 ","date":"2024-04-18","objectID":"http://localhost:1313/posts/drf/:5:2","tags":null,"title":"Drf整合","uri":"http://localhost:1313/posts/drf/"},{"categories":["default"],"content":"5.3 数据序列化以及校验 class InfoView(MineApiView): def post(self, request): ser = Info2Serializer(data=request.data) if ser.is_valid(): instance = ser.save() # ModelSerializer 自带的数保存功能,如果用户提交的数据比orm的少，可以手动加几个进去 ser.save(x1=xxx,x2=xxx) return Response(ser.data) return Response(ser.errors) 值得注意的是，前面我们在校验方法中抛出的异常并不会真正的抛出，而是被序列化器自己处理掉，如果希望抛出到视图函数层面的话仅需在is_valid()中加入参数即可，而加入参数后，异常会被视图函数层面捕获到，也就不会往下走了，所以这样修改甚至不需要if条件 class InfoView(MineApiView): def post(self, request): ser = Info2Serializer(data=request.data) ser.is_valid(): instance = ser.save(raise_exception=True) # 如果没有通过，此处就会报错，当然会被试图层面的dispath方法捕获到，打包成错误信息返回，效果和前面一致。 instance = ser.save() # ModelSerializer 自带的数保存功能,如果用户提交的数据比orm的少，可以手动加几个进去 ser.save(x1=xxx,x2=xxx) return Response(ser.data) ","date":"2024-04-18","objectID":"http://localhost:1313/posts/drf/:5:3","tags":null,"title":"Drf整合","uri":"http://localhost:1313/posts/drf/"},{"categories":["default"],"content":"6.自定义异常返回 # settings.py REST_FRAMEWORK = { 'EXCEPTION_HANDLER': 'utils.exc_views.exception_handler', } from django.http import Http404 from rest_framework import exceptions from rest_framework.response import Response from rest_framework.exceptions import ValidationError from rest_framework.exceptions import Throttled from rest_framework.exceptions import PermissionDenied from rest_framework.exceptions import NotAuthenticated from rest_framework.exceptions import AuthenticationFailed from rest_framework.views import set_rollback from rest_framework.exceptions import APIException class ExtraException(APIException): pass def exception_handler(exc, context): if isinstance(exc, Http404): exc = exceptions.NotFound() exc.ret_code = 2001 elif isinstance(exc, PermissionDenied): exc = exceptions.PermissionDenied() exc.ret_code = 2002 elif isinstance(exc, (AuthenticationFailed, NotAuthenticated)): exc.ret_code = 2003 elif isinstance(exc, Throttled): exc.ret_code = 2004 elif isinstance(exc, ValidationError): exc.ret_code = 2005 # ... if isinstance(exc, exceptions.APIException): headers = {} if getattr(exc, 'auth_header', None): headers['WWW-Authenticate'] = exc.auth_header if getattr(exc, 'wait', None): headers['Retry-After'] = '%d' % exc.wait # if isinstance(exc.detail, (list, dict)): # data = exc.detail # else: # exc_code = getattr(exc, 'ret_code', None) or -1 # data = {'code': exc_code, 'detail': exc.detail} exc_code = getattr(exc, 'ret_code', None) or -1 data = {'code': exc_code, 'detail': exc.detail} set_rollback() return Response(data, status=exc.status_code, headers=headers) # return None data = {'code': -1, 'detail': str(exc)} return Response(data, status=500) ","date":"2024-04-18","objectID":"http://localhost:1313/posts/drf/:6:0","tags":null,"title":"Drf整合","uri":"http://localhost:1313/posts/drf/"},{"categories":["default"],"content":"7 自定义返回值 from django.shortcuts import render from rest_framework.views import APIView from rest_framework.response import Response from django.shortcuts import HttpResponse from rest_framework.views import exception_handler from rest_framework.authentication import BaseAuthentication from rest_framework.exceptions import AuthenticationFailed from utils.exc_views import ExtraException class MineAPIView(APIView): def finalize_response(self, request, response, *args, **kwargs): response = super().finalize_response(request, response, *args, **kwargs) # 1.非正常返回 if response.exception: return response # 2.正常数据返回 response.data = {\"code\": 0, \"data\": response.data} return response 接下来让视图先继承我们自己写的类，它在寻找这个finalize_response方法的时候，就会被我们写的所覆盖掉。 ","date":"2024-04-18","objectID":"http://localhost:1313/posts/drf/:7:0","tags":null,"title":"Drf整合","uri":"http://localhost:1313/posts/drf/"},{"categories":["default"],"content":"8 分页组件 drf提供的几个默认分页组件 BasePagination，分页基类 PageNumberPagination(BasePagination) 支持 /accounts/?page=4\u0026page_size=100 格式的分页 LimitOffsetPagination(BasePagination) 支持 ?offset=100\u0026limit=10 格式的分页 CursorPagination(BasePagination) 支持 上一下 \u0026 下一页 格式的分页（不常用） ","date":"2024-04-18","objectID":"http://localhost:1313/posts/drf/:8:0","tags":null,"title":"Drf整合","uri":"http://localhost:1313/posts/drf/"},{"categories":["default"],"content":"PageNumberPagination ","date":"2024-04-18","objectID":"http://localhost:1313/posts/drf/:8:1","tags":null,"title":"Drf整合","uri":"http://localhost:1313/posts/drf/"},{"categories":["default"],"content":"LimitOffsetPagination ","date":"2024-04-18","objectID":"http://localhost:1313/posts/drf/:8:2","tags":null,"title":"Drf整合","uri":"http://localhost:1313/posts/drf/"},{"categories":["default"],"content":"9 条件搜索 ","date":"2024-04-18","objectID":"http://localhost:1313/posts/drf/:9:0","tags":null,"title":"Drf整合","uri":"http://localhost:1313/posts/drf/"},{"categories":["default"],"content":"自定义Filter # urls.py from django.urls import path from app01 import views urlpatterns = [ path('api/users/', views.UserView.as_view( {\"get\": \"list\", \"post\": \"create\"} )), path('api/users/\u003cint:pk\u003e/', views.UserView.as_view( {\"get\": \"retrieve\", \"put\": \"update\", \"patch\": \"partial_update\", \"delete\": \"destroy\"} )), ] from rest_framework import serializers from rest_framework.viewsets import ModelViewSet from rest_framework.filters import BaseFilterBackend from app01 import models class UserModelSerializer(serializers.ModelSerializer): level_text = serializers.CharField( source=\"get_level_display\", read_only=True ) extra = serializers.SerializerMethodField(read_only=True) class Meta: model = models.UserInfo fields = [\"username\", \"age\", \"email\", \"level_text\", \"extra\"] def get_extra(self, obj): return 666 class Filter1(BaseFilterBackend): def filter_queryset(self, request, queryset, view): age = request.query_params.get('age') if not age: return queryset return queryset.filter(age=age) class Filter2(BaseFilterBackend): def filter_queryset(self, request, queryset, view): user_id = request.query_params.get('id') if not user_id: return queryset return queryset.filter(id__gt=user_id) class UserView(ModelViewSet): filter_backends = [Filter1, Filter2] queryset = models.UserInfo.objects.all() serializer_class = UserModelSerializer def perform_create(self, serializer): \"\"\" 序列化：对请求的数据校验成功后，执行保存。\"\"\" serializer.save(depart_id=1, password=\"123\") ","date":"2024-04-18","objectID":"http://localhost:1313/posts/drf/:9:1","tags":null,"title":"Drf整合","uri":"http://localhost:1313/posts/drf/"},{"categories":["default"],"content":"10.视图 ","date":"2024-04-18","objectID":"http://localhost:1313/posts/drf/:10:0","tags":null,"title":"Drf整合","uri":"http://localhost:1313/posts/drf/"},{"categories":["default"],"content":"APIView View，django APIView，drf，在请求到来时，新增了：免除csrf、请求封装、版本、认证、权限、限流的功能。 class GenericAPIView(APIView): pass # 10功能 class GenericViewSet(xxxx.View-2个功能, GenericAPIView): pass # 5功能能 class UserView(GenericViewSet): def get(self,request): pass APIView是drf中 “顶层” 的视图类，在他的内部主要实现drf基础的组件的使用，例如：版本、认证、权限、限流等。 from django.urls import path, re_path, include from app01 import views urlpatterns = [ path('api/users/', views.UserView.as_view()), path('api/users/\u003cint:pk\u003e/', views.UserDetailView.as_view()), ] from rest_framework.views import APIView from rest_framework.response import Response class UserView(APIView): # 认证、权限、限流等 def get(self, request): # 业务逻辑：查看列表 return Response({\"code\": 0, 'data': \"...\"}) def post(self, request): # 业务逻辑：新建 return Response({'code': 0, 'data': \"...\"}) class UserDetailView(APIView): # 认证、权限、限流等 def get(self, request,pk): # 业务逻辑：查看某个数据的详细 return Response({\"code\": 0, 'data': \"...\"}) def put(self, request,pk): # 业务逻辑：全部修改 return Response({'code': 0, 'data': \"...\"}) def patch(self, request,pk): # 业务逻辑：局部修改 return Response({'code': 0, 'data': \"...\"}) def delete(self, request,pk): # 业务逻辑：删除 return Response({'code': 0, 'data': \"...\"}) ","date":"2024-04-18","objectID":"http://localhost:1313/posts/drf/:10:1","tags":null,"title":"Drf整合","uri":"http://localhost:1313/posts/drf/"},{"categories":["default"],"content":"GenericAPIView GenericAPIView 继承APIView，在APIView的基础上又增加了一些功能。例如：get_queryset、get_object等。 实际在开发中一般不会直接继承它，他更多的是担任 中间人的角色，为子类提供公共功能。 from django.urls import path, re_path, include from app01 import views urlpatterns = [ path('api/users/', views.UserView.as_view()), path('api/users/\u003cint:pk\u003e/', views.UserDetailView.as_view()), ] from rest_framework.generics import GenericAPIView from rest_framework.response import Response class UserView(GenericAPIView): queryset = models.UserInfo.objects.filter(status=True) serializer_class = 序列化类 def get(self, request): queryset = self.get_queryset() ser = self.get_serializer(intance=queryset,many=True) print(ser.data) return Response({\"code\": 0, 'data': \"...\"}) ","date":"2024-04-18","objectID":"http://localhost:1313/posts/drf/:10:2","tags":null,"title":"Drf整合","uri":"http://localhost:1313/posts/drf/"},{"categories":["default"],"content":"GenericViewSet GenericViewSet类中没有定义任何代码，他就是继承 ViewSetMixin 和 GenericAPIView，也就说他的功能就是将继承的两个类的功能继承到一起。 GenericAPIView，将数据库查询、序列化类的定义提取到类变量中，便于后期处理。 ViewSetMixin，将 get/post/put/delete 等方法映射到 list、create、retrieve、update、partial_update、destroy方法中，让视图不再需要两个类。 from django.urls import path, re_path, include from app01 import views urlpatterns = [ path('api/users/', views.UserView.as_view({\"get\":\"list\",\"post\":\"create\"})), path('api/users/\u003cint:pk\u003e/', views.UserView.as_view({\"get\":\"retrieve\",\"put\":\"update\",\"patch\":\"partial_update\",\"delete\":\"destory\"})), ] # views.py from rest_framework.viewsets import GenericViewSet from rest_framework.response import Response class UserView(GenericViewSet): # 认证、权限、限流等 queryset = models.UserInfo.objects.filter(status=True) serializer_class = 序列化类 def list(self, request): # 业务逻辑：查看列表 queryset = self.get_queryset() ser = self.get_serializer(intance=queryset,many=True) print(ser.data) return Response({\"code\": 0, 'data': \"...\"}) def create(self, request): # 业务逻辑：新建 return Response({'code': 0, 'data': \"...\"}) def retrieve(self, request,pk): # 业务逻辑：查看某个数据的详细 return Response({\"code\": 0, 'data': \"...\"}) def update(self, request,pk): # 业务逻辑：全部修改 return Response({'code': 0, 'data': \"...\"}) def partial_update(self, request,pk): # 业务逻辑：局部修改 return Response({'code': 0, 'data': \"...\"}) def destory(self, request,pk): # 业务逻辑：删除 return Response({'code': 0, 'data': \"...\"})from rest_framework.viewsets import GenericViewSetfrom rest_framework.response import Response​ class UserView(GenericViewSet): # 认证、权限、限流等 queryset = models.UserInfo.objects.filter(status=True) serializer_class = 序列化类 def list(self, request): # 业务逻辑：查看列表 queryset = self.get_queryset() ser = self.get_serializer(intance=queryset,many=True) print(ser.data) return Response({\"code\": 0, 'data': \"...\"})​ def create(self, request): # 业务逻辑：新建 return Response({'code': 0, 'data': \"...\"}) def retrieve(self, request,pk): # 业务逻辑：查看某个数据的详细 return Response({\"code\": 0, 'data': \"...\"})​ def update(self, request,pk): # 业务逻辑：全部修改 return Response({'code': 0, 'data': \"...\"}) def partial_update(self, request,pk): # 业务逻辑：局部修改 return Response({'code': 0, 'data': \"...\"}) def destory(self, request,pk): # 业务逻辑：删除 return Response({'code': 0, 'data': \"...\"}) 注意：开发中一般也很少直接去继承他，因为他也属于是 中间人类，在原来 GenericAPIView 基础上又增加了一个映射而已。 ","date":"2024-04-18","objectID":"http://localhost:1313/posts/drf/:10:3","tags":null,"title":"Drf整合","uri":"http://localhost:1313/posts/drf/"},{"categories":["default"],"content":"五大类 在drf的为我们提供好了5个用于做 增、删、改（含局部修改）、查列表、查单个数据的5个类（需结合 GenericViewSet 使用）。 from django.urls import path, re_path, include from app01 import views urlpatterns = [ path('api/users/', views.UserView.as_view({\"get\":\"list\",\"post\":\"create\"})), path('api/users/\u003cint:pk\u003e/', views.UserView.as_view({\"get\":\"retrieve\",\"put\":\"update\",\"patch\":\"partial_update\",\"delete\":\"destroy\"})), ] from rest_framework.viewsets import GenericViewSet from rest_framework.mixins import ( ListModelMixin, CreateModelMixin, RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin, ListModelMixin ) class UserView(CreateModelMixin,RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin,ListModelMixin,GenericViewSet): # 认证、权限、限流等 queryset = models.UserInfo.objects.filter(status=True) serializer_class = 序列化类 在这个5个类中已帮我们写好了 list、create、retrieve、update、partial_update、destory 方法，我们只需要在根据写 类变量：queryset、serializer_class即可。 # urls.py from django.urls import path from app01 import views urlpatterns = [ path('api/users/', views.UserView.as_view({\"get\": \"list\"})), path('api/users/\u003cint:pk\u003e/', views.UserView.as_view({\"get\": \"retrieve\"})), ] from rest_framework import serializers from rest_framework.viewsets import GenericViewSet from rest_framework import mixins from app01 import models class UserModelSerializer(serializers.ModelSerializer): level_text = serializers.CharField( source=\"get_level_display\", read_only=True ) extra = serializers.SerializerMethodField(read_only=True) class Meta: model = models.UserInfo fields = [\"username\", \"age\", \"email\", \"level_text\", \"extra\"] def get_extra(self, obj): return 666 class UserView(mixins.ListModelMixin, mixins.RetrieveModelMixin, GenericViewSet): queryset = models.UserInfo.objects.all() serializer_class = UserModelSerializer ","date":"2024-04-18","objectID":"http://localhost:1313/posts/drf/:10:4","tags":null,"title":"Drf整合","uri":"http://localhost:1313/posts/drf/"},{"categories":["default"],"content":"快速上手websocket 在dj中 #环境： python 3.9 django4.2 pip install channels pip install daphne ","date":"2024-04-18","objectID":"http://localhost:1313/posts/websocket/:0:0","tags":null,"title":"Websocket","uri":"http://localhost:1313/posts/websocket/"},{"categories":["default"],"content":"dj的使用 安装好后，我们要先知道django是通过wsgi进行启动的。但是默认情况下，wsgi是无法支持websocket的， 因此安装好后，先去setting中注册channels ``` INSTALLED_APPS = [ # \"daphne\", #有时候直接这样引入会报错，直接手动指定该app的配置即可 \"daphne.apps.DaphneConfig\", 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', ] ``` 现在基于daphne来替换wsgi来启动项目，同样在settings中 ``` # settings.py WSGI_APPLICATION = 'websocket_dj.wsgi.application' ASGI_APPLICATION = 'websocket_dj.asgi.application' ``` 然后启动就可以看到程序是通过ASGI/Daphne启动的了，此时同时支持异步和websocket协议了。 但是此时打开asgi.py 需要进行一些配置，同时需要利用channels，这需要到settings中进行配置 ``` # settings.py INSTALLED_APPS = [ \"daphne.apps.DaphneConfig\", 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', \"channels\", \"app01.apps.App01Config\" ] # asgi.py import os from django.core.asgi import get_asgi_application from channels.routing import ProtocolTypeRouter, URLRouter from .routing import websocket_urlpatterns os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'websocket_dj.settings') # application = get_asgi_application() application = ProtocolTypeRouter({ \"http\": get_asgi_application(), # 如果是http协议那么就会使用get_asgi_application() \"websocket\": URLRouter(websocket_urlpatterns), # 可以指定websocket 相应的路由 }) ``` 接下来就可以去websocket_urlpatterns中编写对应的路由了，几乎可以类似于传统的django路由 ``` # websocket 协议路由 from django.urls import path from app01 import views from app01 import views websocket_urlpatterns = [ path(\"room/\", views.ChatConsumen.as_asgi()) ] ## views.py from channels.generic.websocket import WebsocketConsumer from channels.exceptions import StopConsumer class ChatConsumen(WebsocketConsumer): def websocket_connect(self, message): print(\"有人连接了\") self.accept() def websocket_receive(self, message): print(\"接收到消息了\", message) self.send(text_data=\"收到了\") def websocket_disconnect(self, message): print(\"客户端断开连接了\") raise StopConsumer() ``` 此时通过前端脚本，建立连接并且实时准备接收后台的消息 ```html \u003cinput type=\"text\" id=\"txt\"/\u003e \u003cinput type=\"button\" value=\"发送\" onclick=\"dosend()\"/\u003e \u003cinput type=\"button\" value=\"关闭\" onclick=\"doclose()\"\u003e \u003cscript type=\"text/javascript\"\u003e // ws://127.0.0.1:8000/room/ var ws = new WebSocket(\"ws://\" + window.location.host + \"/room/\") ws.onmessage = function (event) { console.log(event.data) } function dosend() { let text = document.getElementById(\"txt\").value ws.send(text) } function doclose() { ws.close() } \u003c/script\u003e \u003c ``` ","date":"2024-04-18","objectID":"http://localhost:1313/posts/websocket/:1:0","tags":null,"title":"Websocket","uri":"http://localhost:1313/posts/websocket/"},{"categories":["default"],"content":"案例1： 聊天室 思路梳理 访问并显示 -http:127.0.0.1:8000/index/?group=1008 ``` from channels.exceptions import StopConsumer,AcceptConnection,DenyConnection,InvalidChannelLayerError from asgiref.sync import async_to_sync LIVE_DICT = { } class ChatConsumen(WebsocketConsumer): def websocket_connect(self, message): print(\"有人连接了\"), # print(\"self.scope.url_route\", self.scope['url_route']['kwargs']['group']) group = self.scope['url_route']['kwargs']['group'] LIVE_DICT.setdefault(group, []) # 如果对应聊天室不存在默认创建一个空列表 LIVE_DICT[group].append(self) # 将当前建立的这个websocket连接实例对象假如到字典，中 后续可以通过对象.send来实现对客户端发送消息 self.accept() def websocket_receive(self, message): # print(\"接收到消息了\", message) group = self.scope['url_route']['kwargs']['group'] for client in LIVE_DICT[group]: # 拿到所有的ChatConsumen对象，执行.send 把消息广播给客户端 client.send(text_data=message['text']) # self.send(text_data=\"收到了\") def websocket_disconnect(self, message): print(\"客户端断开连接了\") group = self.scope['url_route']['kwargs']['group'] LIVE_DICT[group].remove(self) # 退出聊天群，直接踢出 raise StopConsumer() ``` ","date":"2024-04-18","objectID":"http://localhost:1313/posts/websocket/:2:0","tags":null,"title":"Websocket","uri":"http://localhost:1313/posts/websocket/"},{"categories":["default"],"content":"案例2 channels 聊天室 安装channels-redis pip install channels-redis 配置CHANNEL_LAYERS ``` # settings.py CHANNEL_LAYERS = { \"default\": { \"BACKEND\": \"channels_redis.core.RedisChannelLayer\", \"CONFIG\": { \"hosts\": [(\"127.0.0.1\", 6379)] # \"hosts\": [\"redis://xxxxx密码@127.0.0.1:6379\"], } } } ``` 此时group就不需要通过group字典来进行存储了 然后对应的视图处理函数需要进行简单的修改 from channels.exceptions import StopConsumer,AcceptConnection,DenyConnection,InvalidChannelLayerError from asgiref.sync import async_to_sync # 基于channel redis class ChatConsumen(WebsocketConsumer): def websocket_connect(self, message): print(\"有人连接了\"), # print(\"self.scope.url_route\", self.scope['url_route']['kwargs']['group']) group = self.scope['url_route']['kwargs']['group'] # 将客户端对象，添加到redis中 async_to_sync(self.channel_layer.group_add)(group,self.channel_name) self.accept() def websocket_receive(self, message): # print(\"接收到消息了\", message) group = self.scope['url_route']['kwargs']['group'] async_to_sync(self.channel_layer.group_send)(group,{\"type\":\"xx.oo\",\"message\":message}) # self.send(text_data=\"收到了\") def xx_oo(self,event): text = event[\"message\"][\"text\"] self.send(text) def websocket_disconnect(self, message): print(\"客户端断开连接了\") group = self.scope['url_route']['kwargs']['group'] async_to_sync(self.channel_layer.group_discard)( # 移除内容 group,self.channel_name ) raise StopConsumer() ","date":"2024-04-18","objectID":"http://localhost:1313/posts/websocket/:3:0","tags":null,"title":"Websocket","uri":"http://localhost:1313/posts/websocket/"},{"categories":["default"],"content":"jwt算法 问题描述: ​ 传统的登录状态token，通常会保存在数据库或者缓存中，这其实增加服务器的压力，那么有没有什么方法，可以在不需要保存token，却又能让系统记住这个所谓的\"token\"呢， 当然是有的，他就是jwt。 ","date":"2024-04-17","objectID":"http://localhost:1313/posts/jwt/:0:0","tags":null,"title":"Jwt算法","uri":"http://localhost:1313/posts/jwt/"},{"categories":["default"],"content":"jwt 密文结构 # 由三段字符串组成，中间用.将其隔开 xxxxx.xxxxx.xxxx ","date":"2024-04-17","objectID":"http://localhost:1313/posts/jwt/:1:0","tags":null,"title":"Jwt算法","uri":"http://localhost:1313/posts/jwt/"},{"categories":["default"],"content":"jwt 加密思路： 假如我拿到如下用户信息 { \"username\":\"yutianwang\", \"password\":\"123123\" } jtw加密的思路其实就是分成三步，分别生成三段密文（包括根据给出用户信息的json串） ","date":"2024-04-17","objectID":"http://localhost:1313/posts/jwt/:2:0","tags":null,"title":"Jwt算法","uri":"http://localhost:1313/posts/jwt/"},{"categories":["default"],"content":"第一段密文 先注意如下json字符串，先将其进行base64url 编码 { \"alg\":\"HS256\", \"typ\":\"JWT\" } ## 使用python代码处理 import base64 import json original_data = { \"alg\":\"HS256\", \"typ\":\"JWT\" } json_data = json.dumps(original_data).encode('utf8') encoded_data = base64.b64encode(json_data).decode('utf8') print(encoded_data) 然后我们拿到了这么一个东西： eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9 这个东西将来就是jwt的第一段(可以说是固定内容) ","date":"2024-04-17","objectID":"http://localhost:1313/posts/jwt/:2:1","tags":null,"title":"Jwt算法","uri":"http://localhost:1313/posts/jwt/"},{"categories":["default"],"content":"第二段密文 拿到用户信息 { \"id\":\"1234567890\", \"name\":\"John Doe\", \"time\":\"1516239022\" } 同样先进行base64url编码，拿到这个玩意 eyJpZCI6ICIxMjM0NTY3ODkwIiwgIm5hbWUiOiAiSm9obiBEb2UiLCAidGltZSI6ICIxNTE2MjM5MDIyIn0= 它就是jwt中的第二段密文 ","date":"2024-04-17","objectID":"http://localhost:1313/posts/jwt/:2:2","tags":null,"title":"Jwt算法","uri":"http://localhost:1313/posts/jwt/"},{"categories":["default"],"content":"第三段密文 第三段密文思路如下 base64url(HS256(第一段密文.第二段密文),密钥加盐) 最后将三段密文内容都用.拼接起来就的到了最终密文 ","date":"2024-04-17","objectID":"http://localhost:1313/posts/jwt/:2:3","tags":null,"title":"Jwt算法","uri":"http://localhost:1313/posts/jwt/"},{"categories":null,"content":"作者介绍 一个计算机专业的菜鸟 联系方式 qq: 1257091748 电话号码: 17879765153 邮箱: 17879765153@163.com 微信: 余天王微信\r兴趣爱好 旅游 吃 听歌 关于计算机的一切 涉猎内容 测试内容 测试内容 ","date":"2024-04-15","objectID":"http://localhost:1313/about/:0:0","tags":null,"title":"作者","uri":"http://localhost:1313/about/"},{"categories":["deploy"],"content":"关于redis各平台的安装","date":"2024-04-14","objectID":"http://localhost:1313/posts/redis/","tags":null,"title":"redis安装","uri":"http://localhost:1313/posts/redis/"},{"categories":["deploy"],"content":"1： 学习环境介绍： windows + vmware:centos 7 redis3.0.7 2: redis 5.0 版本安装,以及配置 下载安装 所有版本下载链接：链接1 mkdir -p /data/redis6379 cd /opt # yum -y install wget wget https://download.redis.io/releases/redis-5.0.7.tar.gz tar -zxf redis-5.0.7.tar.gz cd /opt/redis-5.0.7 make \u0026\u0026 make install 关于编译安装的命令： # 有一份二进制的软件包，想要安装，一般有以下几个步骤 ./configure .... # 洗菜和切菜，指定安装目录和配置等 make # 炒菜，编译安装软件 make install # 装盘，根据./configure的配置进行实际安装到指定位置 安装完成后，Redis可执行程序会自动添加到/usr/local/bin路径，我们就可以在任何地方的terminal中使用Redis相关命令了。 [root@cs opt]# ll /usr/local/bin/redis* -rwxr-xr-x. 1 root root 4365728 Aug 1 10:58 /usr/local/bin/redis-benchmark -rwxr-xr-x. 1 root root 8124120 Aug 1 10:58 /usr/local/bin/redis-check-aof -rwxr-xr-x. 1 root root 8124120 Aug 1 10:58 /usr/local/bin/redis-check-rdb -rwxr-xr-x. 1 root root 4806800 Aug 1 10:58 /usr/local/bin/redis-cli lrwxrwxrwx. 1 root root 12 Aug 1 10:58 /usr/local/bin/redis-sentinel -\u003e redis-server -rwxr-xr-x. 1 root root 8124120 Aug 1 10:58 /usr/local/bin/redis-server 到这一步，我们就可以在任意路径下，调用redis的相关命令了，如： [root@cs opt]# redis-server -v Redis server v=5.0.7 sha=00000000:0 malloc=jemalloc-5.1.0 bits=64 build=a67ef2d8861912e7 4. 编写配置文件 无密码配置： mkdir -p /opt/redis6379/{conf,logs,pid} cat \u003e/opt/redis6379/conf/redis6379.conf\u003c\u003cEOF daemonize yes # 注意，生产中， 千万不要bind 0.0.0.0，不要将Redis暴露到外网环境，防止被人攻击 bind 127.0.0.1 $(ifconfig ens33|awk 'NR==2{print $2}') port 6379 pidfile /opt/redis6379/pid/redis6379.pid logfile /opt/redis6379/logs/redis6379.log EOF 5. 启动命令 redis-server /opt/redis6379/conf/redis6379.conf ps -ef|grep redis 6. 客户端连接 无密码的，客户端直接连接就可以操作，并且支持远程连接： [root@cs opt]# redis-cli 127.0.0.1:6379\u003e ping PONG 127.0.0.1:6379\u003e quit [root@cs opt]# 7. 关闭命令 # 结合启动命令测试关闭命令 redis-server /opt/redis6379/conf/redis6379.conf ps -ef|grep redis # 方式1 [root@cs opt]# redis-cli 127.0.0.1:6379\u003e SHUTDOWN not connected\u003e quit [root@cs opt]# # 方式2 [root@cs opt]# redis-cli shutdown [root@cs opt]# # 方式3 [root@cs opt]# pkill -9 redis [root@cs opt]# 8. 可选的配置，配置systemd管理Redis # 先把之前可能运行的Redis停止 # 创建redis用户和组，以及给相关目录权限 # 创建systemctl管理redis的文件 # 就可以通过systemctl管理redis了 redis-cli shutdown # -u和-g选项表示同时添加具有特定UID和GID的用户 # -M创建一个没有主目录的用户 # -s表示当前创建的当前用户无法用来登录系统 # chown -R redis:redis表示指定目录以及内部的文件所有用户属组归于redis:redis # groupdel redis # cat /etc/group |grep redis groupadd redis -g 1000 # userdel redis # cat /etc/passwd |grep redis useradd redis -u 1000 -g 1000 -M -s /sbin/nologin chown -R redis:redis /opt/redis* chown -R redis:redis /data/redis* cat \u003e/usr/lib/systemd/system/redis.service\u003c\u003cEOF [Unit] Description=Redis persistent key-value database After=network.target After=network-online.target Wants=network-online.target [Service] ExecStart=/usr/local/bin/redis-server /opt/redis6379/conf/redis6379.conf --supervised systemd ExecStop=/usr/local/bin/redis-cli shutdown Type=notify User=redis Group=redis RuntimeDirectory=redis RuntimeDirectoryMode=0755 [Install] WantedBy=multi-user.target EOF systemctl daemon-reload # 当添加或者修改了某个服务的配置文件，就要执行daemon-reload命令重新加载下 systemctl start redis # 启动/停止/重启/查看状态/设置redis开机自启 systemctl start/stop/restart/status/enable redis 到此，安装成功了。 ","date":"2024-04-14","objectID":"http://localhost:1313/posts/redis/:0:0","tags":null,"title":"redis安装","uri":"http://localhost:1313/posts/redis/"},{"categories":["deploy"],"content":"优化警告# 如果你查看redis的日志，你会发现启动，日志中会出现一些警告，我们可以针对性的优化这些警告。 cat /opt/redis6379/logs/redis6379.log ","date":"2024-04-14","objectID":"http://localhost:1313/posts/redis/:1:0","tags":null,"title":"redis安装","uri":"http://localhost:1313/posts/redis/"},{"categories":["deploy"],"content":"警告1：maximum open files过低# 就是客户端连接数有点小了，改大点就行了 63918:M 01 Aug 2023 11:28:59.700 # You requested maxclients of 10000 requiring at least 10032 max file descriptors. 63918:M 01 Aug 2023 11:28:59.700 # Server can't set maximum open files to 10032 because of OS error: Operation not permitted. 63918:M 01 Aug 2023 11:28:59.700 # Current maximum open files is 4096. maxclients has been reduced to 4064 to compensate for low ulimit. If you need higher maxclients increase 'ulimit -n'. 解决，systemd启动文件添加参数LimitNOFILE： cat \u003e/usr/lib/systemd/system/redis.service\u003c\u003cEOF [Unit] Description=Redis persistent key-value database After=network.target After=network-online.target Wants=network-online.target [Service] ExecStart=/usr/local/bin/redis-server /opt/redis6379/conf/redis6379.conf --supervised systemd ExecStop=/usr/local/bin/redis-cli shutdown Type=notify User=redis Group=redis RuntimeDirectory=redis RuntimeDirectoryMode=0755 LimitNOFILE=65536 [Install] WantedBy=multi-user.target EOF ","date":"2024-04-14","objectID":"http://localhost:1313/posts/redis/:1:1","tags":null,"title":"redis安装","uri":"http://localhost:1313/posts/redis/"},{"categories":["deploy"],"content":"警告2：overcommit_memory设置# 虚拟内存相关，overcommit_memory 表内存分配策略，可选值：0、1、2 0，表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程。 1， 表示内核允许分配所有的物理内存，而不管当前的内存状态如何。 2， 表示内核允许分配超过所有物理内存和交换空间总和的内存 63918:M 01 Aug 2023 11:28:59.701 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect., 解决： # 临时解决 sysctl vm.overcommit_memory=1 # 永久解决 vim /etc/sysctl.conf 追加： vm.overcommit_memory=1 # 生效配置 sysctl -p ","date":"2024-04-14","objectID":"http://localhost:1313/posts/redis/:1:2","tags":null,"title":"redis安装","uri":"http://localhost:1313/posts/redis/"},{"categories":["deploy"],"content":"警告3：关闭THP⼤内存⻚# redis建议我们关掉THP，还给出的具体的操作办法，注意必须使用root来操作，否则会失败。 Linux kernel 在 2.6.38 的版本中新增了 THP 的特性，支持大内存页（2MB）分配，默认开启。 当开启 THP 时会降低 fork 子进程的速度，但是 fork 操作之后，每个内存页从原来 4KB 变为 2MB，会大幅增加重写期间父进程内存消耗。 同时每次写命令引起的复制内存也单位放大了 512 倍，会拖慢写操作的时间，导致大量写操作慢查询，例如：简单的 incr、set 命令也会出现在慢查询中。 63918:M 01 Aug 2023 11:28:59.701 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never \u003e /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled. 解决，必须以root用户执行下面的命令： # 临时解决 echo never \u003e /sys/kernel/mm/transparent_hugepage/enabled # 永久解决 vim /etc/rc.local 追加： echo never \u003e /sys/kernel/mm/transparent_hugepage/enabled ","date":"2024-04-14","objectID":"http://localhost:1313/posts/redis/:1:3","tags":null,"title":"redis安装","uri":"http://localhost:1313/posts/redis/"},{"categories":["deploy"],"content":"警告4：TCP连接数调整# 意思是配置 /proc/sys/net/core/somaxconn的值是128，但redis.conf中配置的是511，但是linux内核会以无提示的方式将其截断为128。在一个高并发的环境下，128是远远不够的，所以我们要改大一些。 63918:M 01 Aug 2023 11:28:59.701 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128. 解决： # 永久解决 vim /etc/sysctl.conf 追加： net.core.somaxconn= 4096 # 生效配置 sysctl -p 然后在重启下redis，并观察日志： # 先清空原有的日志内容 # 然后重启redis # 观察日志输出 echo \"\"\u003e/opt/redis6379/logs/redis6379.log cat /opt/redis6379/logs/redis6379.log systemctl daemon-reload systemctl stop redis systemctl status redis systemctl start redis systemctl status redis cat /opt/redis6379/logs/redis6379.log # 这输出就很干净了啊 [root@cs opt]# cat /opt/redis6379/logs/redis6379.log 79069:C 01 Aug 2023 12:05:05.217 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo 79069:C 01 Aug 2023 12:05:05.217 # Redis version=5.0.7, bits=64, commit=00000000, modified=0, pid=79069, just started 79069:C 01 Aug 2023 12:05:05.217 # Configuration loaded 79069:C 01 Aug 2023 12:05:05.217 * supervised by systemd, will signal readiness 79069:M 01 Aug 2023 12:05:05.218 * Running mode=standalone, port=6379. 79069:M 01 Aug 2023 12:05:05.218 # Server initialized 79069:M 01 Aug 2023 12:05:05.219 * Ready to accept connections 最终这些调整完，最好重启下服务器。然后再启动下redis就好了。 3:关于密码# 如果需要密码，用下面的配置： mkdir -p /opt/redis6379/{conf,logs,pid} cat \u003e/opt/redis6379/conf/redis6379.conf\u003c\u003cEOF daemonize yes # 注意，生产中， 千万不要bind 0.0.0.0，不要将Redis暴露到外网环境，防止被人攻击，这里为了演示方便才这么做的 bind 0.0.0.0 # requirepass 后面跟空格，空格后面是你要设置的密码 requirepass 1234 port 6379 pidfile /opt/redis6379/pid/redis6379.pid logfile /opt/redis6379/logs/redis6379.log EOF systemctl restart redis 更改了配置文件，别忘了重启Redis。 有密码的，这么连接： [root@cs opt]# redis-cli # 这里默认连接的是6379端口的Redis服务 127.0.0.1:6379\u003e ping (error) NOAUTH Authentication required. # 由于我设置了密码，所以，这里提示需要认证，如果你没有设置密码，这里应该返回PONG 来说下认证的两种方式。下面是访问的同时携带密码，连接认证一起做了。 # -a 后面跟你的密码 # -p 后面是6379端口，其实这个-p参数可以不带，不带默认就是访问的6379端口的Redis [root@cs opt]# redis-cli -a 1234 -p 6379 127.0.0.1:6379\u003e ping PONG 127.0.0.1:6379\u003e 另一种方式就是，先连接上，然后再认证： [root@cs opt]# redis-cli # 连接肯定是没问题，但由于设置了密码，你未通过认证之前，你啥也做不了 127.0.0.1:6379\u003e ping (error) NOAUTH Authentication required. 127.0.0.1:6379\u003e auth 1234 # 认证，auth命令后面跟你的密码 OK 127.0.0.1:6379\u003e ping # 认证通过，你想干啥干啥 PONG 127.0.0.1:6379\u003e quit # 常见的退出客户端命令有： quit/exit/ctrl+c 注意，退出客户端只是表示关闭客户端和服务端的连接，而不是停止服务端，这点要区分开 [root@cs opt]# 4：redis常用的全局命令： 对所有的数据类型都生效的命令。 # 高危命令，生产禁用！返回所有的redis中所有的key，尽量避免在生产中使用 KEYS * # 查询以k2开头的所有KEYS KEYS k2* # 返回指定key的值 KEYS k1 # 返回当前数据库中key的总数，这个先相当于是个计数器，生产中可以用 DBSIZE # 返回指定key的value值的类型 TYPE k1 # 删除一个key，key存在并且删除成功，返回1，否则返回0 # 删除n个key，并且都删除成功，返回删除成功的key的个数 DEL k1 DEL k1 k2 ...kn # 判断 key 是否存在,如果返回0，表示key不存在，如果判断多个key，例如，EXISTS k1 k2 k3，如果都存在，返回3 # 如果返回0表示都不存在，返回1,2的话，就表示只有这一两个key存在 EXISTS k1 EXISTS k1 k2 ... kn # 重命名 RENAME k1 k11 # 查看所有的配置项 CONFIG GET * # 以键值对的形式返回所有的配置项 CONFIG GET appendonly # 查看指定配置项 CONFIG SET requirepass 1234 # 临时动态的设置某个设置，重启redis失效，想要永久的，还是要手动的写入到配置文件中 CONFIG REWRITE # 将临时动态设置的某个设置，刷写到配置文件中 # 高危命令，生产禁用！清空redis中所有的key，找都找不回来的那种清空，如果用了，请尽早买好跑路的高铁票 FLUSHALL # 查看服务端，此时此刻的客户端连接数 INFO CLIENTS # 查看服务端支持的最大的客户端连接数 CONFIG GET maxclients 设置键值对的生存时间： # 以秒/毫秒为单位设置生存时间 EXPIRE/PEXPIRE # 以秒/毫秒为单位返回剩余的生存时间 TTL/PTTL # 即在生存时间内，取消生存时间设置 PERSIST # 为 k2 设置生存时间为20秒，关于返回值 # 0 表示key不存在 # 1 表示key存在，且设置过期时间成功 EXPIRE k2 20 # 返回 k2 剩余的生存时间，关于返回值 # -1 表示key存在且永不过期 # -2 表示key不存在 # n 表示key存在，还有n秒后过期 TTL k2 # 取消过期时间设置，或者你可以重新 set k2 v2 当然，set这种不够优雅 PERSIST k2 注意，不要将大量的键值对设置为同一时间失效，避免造成缓存雪崩！ redis存储数据的上限 由于Redis是一个基于内存的数据库，所以它的数据存储在内存中，那么Redis数据大小限制取决于内存的大小。 因此，当Redis中的数据超过可用内存时，它将开始使用交换空间（swap space）或溢出文件（overflow file），这将导致系统变慢或崩溃。因此，我们需要注意Redis中数据大小的限制，以便避免这些问题的发生。 单个键值对的大小限制：Redis最大可以存储512MB的数据，因此，单个键值对的大小不能超过512MB。超过这个大小将导致数据丢失或内存中断。 Redis数据库的大小限制：每个Redis数据库默认可以最多存储2^32个键值对，当达到这个限制后，将无法再向其添加更多数据。 ","date":"2024-04-14","objectID":"http://localhost:1313/posts/redis/:1:4","tags":null,"title":"redis安装","uri":"http://localhost:1313/posts/redis/"},{"categories":["deploy"],"content":"禁用高危命令# 刚才学了一些命令，你可以发现有些高危命令是生产中禁止使用的，那么相信人的自觉性肯定是不靠谱的，我们需要禁用掉这些命令。 打开你的redis.conf文件，想要禁用某个命令，可以这样写： # 为某个命令赋值为空字符串，就先当于禁用掉这个命令了 # 你也可以为某个命令重命名，防止自己也没得用 rename-command KEYS \"\" # rename-command KEYS \"KEYSSS\" rename-command SHUTDOWN \"\" rename-command CONFIG \"\" rename-command FLUSHALL \"\" 你应该根据情况决定是禁用掉某个命令还是重命名某个命令。 比如你直接禁用掉到DEL命令，但此时aof文件中有DEL的操作日志，那么当你重启Redis或者调整aof文件时，就会报错，因为没有这个删除命令了….. 5:Redis5-数据类型篇 ","date":"2024-04-14","objectID":"http://localhost:1313/posts/redis/:2:0","tags":null,"title":"redis安装","uri":"http://localhost:1313/posts/redis/"},{"categories":["deploy"],"content":"1：字符串： # 如果k1 存在，那么v1 就覆盖原来的value 值 ，如果key不存在 就是设置key value值 set k1 v1 #set key 的时候 同时设置执行过期时间 （Expiration） setex k1 10 v1 # 也可以这么写 set k1 ex v1 10 # 同时设置多个k/v mset k1 v1 k2 v2 k3 v3 # 查看对应key 的剩余存货时间(time to life) ttl k1 # 判断 k1 是否存在，如果存在返回1 不存在返回0 exists k1 # 查看对应的key的value值 get k1 # 查看多个 mget k1 k2 k3 k4 #如果k1没有，则返回一个nil并赋值，有则返回这个值并覆盖 getset k1 v1 (nil) get k1 \"v1\" # 如果key不存在，就设置一个key:value，如果key存在则什么都不做 # 返回 0 表示key存在，啥也不做 # 返回 1 表示key不存在，设置键值对成功 127.0.0.1:6379\u003e SETNX k1 v1 (integer) 0 # 删除单个key，删除多个key,并返回成功删除的个数 127.0.0.1:6379\u003e DEL k1 (integer) 1 127.0.0.1:6379\u003e DEL k1 k2 k3 (integer) 2 # 表示成功删除两个。 # 追加值，若key不存在，相当于set键值对，若key存在，将append的value拼接到原来key的value的后面 127.0.0.1:6379\u003e APPEND k1 v1 (integer) 2 127.0.0.1:6379\u003e GET k1 \"v1\" 127.0.0.1:6379\u003e APPEND k1 111 (integer) 5 127.0.0.1:6379\u003e GET k1 \"v1111\" # 为指定字节位置的元素替换为指定值从0开始的哦 127.0.0.1:6379\u003e SET k7 0123456789 127.0.0.1:6379\u003e SETRANGE k7 5 A # 将第5个字节位置的值替换为 A (integer) 10 127.0.0.1:6379\u003e GET k7 # 替换后的结果 \"01234A6789\" 127.0.0.1:6379\u003e SETRANGE k7 12 BC # 如果指定的字节数超出字符串长度，就补零 (integer) 14 127.0.0.1:6379\u003e GET k7 \"01234A6789\\x00\\x00BC\" 127.0.0.1:6379\u003e SETRANGE k7 6 7 BC # 不允许这种将第6~7字节位置的元素替换为指定值 (error) ERR wrong number of arguments for 'setrange' command # 判断key是否存在，存在返回1，否则返回0 127.0.0.1:6379\u003e EXISTS k1 (integer) 1 # 如果key存在，返回值的长度，否则返回0 127.0.0.1:6379\u003e STRLEN k1 (integer) 2 127.0.0.1:6379\u003e STRLEN k222 # k222不存在 (integer) 0 # 返回字符串指定字节范围的值 127.0.0.1:6379\u003e SET k7 0123456789 OK 127.0.0.1:6379\u003e GETRANGE k7 1 5 # 第1~5个字节范围内的值，注意，索引从0开始 \"12345\" 127.0.0.1:6379\u003e GETRANGE k7 5 15 # 第5~15个字节范围内的值，如果字符串长度不够，以起始位置开始，有多少返回多少 \"56789\" 127.0.0.1:6379\u003e GETRANGE k7 15 20 # 起始和结束范围都不在字符串范围内，返回空 \"\" 上例中有对范围设置值或者取值的操作，但谨记，不能对中文这么做，因为一个中文由多个字节组成。 计数器功能： 127.0.0.1:6379\u003e INCR num # 每次调用INCR命令，num值自加一，num提前可以不存在 (integer) 1 127.0.0.1:6379\u003e INCR num (integer) 2 127.0.0.1:6379\u003e INCRBY num 10 # 一次性加n (integer) 12 127.0.0.1:6379\u003e INCRBY num 100 (integer) 112 127.0.0.1:6379\u003e DECR num # DECR 使num自减一 (integer) 111 127.0.0.1:6379\u003e decrby num 10 # 一次性减n (integer) 101 127.0.0.1:6379\u003e DECR num1 # 如果num1这个key不存在，则先设置为0，再减一 (integer) -1 127.0.0.1:6379\u003e GET num # 可以通过GET获取该计数器的值 \"101\" 127.0.0.1:6379\u003e GET num1 \"-1\" 127.0.0.1:6379\u003e TYPE num # 注意，值仍然是字符串 string ","date":"2024-04-14","objectID":"http://localhost:1313/posts/redis/:3:0","tags":null,"title":"redis安装","uri":"http://localhost:1313/posts/redis/"},{"categories":["deploy"],"content":"2:列表# 应用场景： 消息队列系统 最新的微博消息，比如我们将最新发布的热点消息都存储到Redis中，只有翻看\"历史久远\"的个人信息，这类冷数据时，才去MySQL中查询 列表的特点： 后插入的在最前面，相当于每次都默认在索引0前面做插入操作。这个特性相当于微信朋友圈，最新发布的的动态在最上面。 列表内每一个元素都有自己的下标索引，从左到右，从0开始；从右到左，从-1开始，这跟Python中的列表一样。 列表中的元素可重复。 # 增 LPUSH l1 a b # 如果 l1 不存在就创建，然后将 a b 插入到 l1 中，如果 l1 存在，直接将 a b 插入到 l1 中 注意 从左边插入，所以a先进去，然后b进去，所以b在a左边 LPUSHX l1 c # 如果 key 存在则插入，不存在则什么也不做 LINSERT l1 before a a1 # 在元素 a 前面插入 a1 LINSERT l1 after a a2 # 在元素 a 后插入 a2 RPUSH l1 1 # 在列表尾部追加 元素 1 RPUSH l1 2 3 # 在列表尾部先追加 2 再追加 3 ,注意这里的插入从左往右就是123了 RPUSHX l1 4 # 如果列表 l1 存在就将元素4追加到列表尾部，如果列表不存在则什么也不做 # 查，根据索引下标取值 LRANGE l1 0 -1 # 从索引0开始取到-1，也就是从头取到尾，获取列表中的所有元素 LRANGE l1 0 2 # 取索引 0 1 2 三个索引对应的元素 LRANGE l1 0 0 # 取索引 0 对应的元素 LRANGE l1 10 15 # 如果索引不在合法范围内，则取空 LINDEX l1 1 # 根据索引下标返回元素 # 删除 DEL l1 # 删除整个列表 LPOP l1 # 抛出列表头部元素 RPOP l1 # 抛出列表尾部元素 RPOPLPUSH l1 l2 # 将列表 l1 尾部的元素抛出并且添加到列表 l2 中 LREM l1 2 a1 # 从左到右，删除指定个数的元素 a1 ，本示例中，若 a1 有 1 个，就删一个，若 a1 有 3 个或者更多，也就删除 2 个 LTRIM l1 2 4 # 保留索引2-4的元素，其余删除 # 改 LSET l1 0 a # 将列表索引为0的元素修改为指定值，如果索引位置不存在则报错 ","date":"2024-04-14","objectID":"http://localhost:1313/posts/redis/:4:0","tags":null,"title":"redis安装","uri":"http://localhost:1313/posts/redis/"},{"categories":["deploy"],"content":"3:Redis-hash# 应用场景： 作为MySQL的缓存。 对应关系： mysql数据格式： user表 id name job age 1 zhang it 18 2 wang it 24 3 zhao it 20 对应hash类型存储格式： key field1 value field2 value field3 value user:1 name zhang job it age 18 user:2 name wang job it age 18 user:3 name zhao job it age 18 user对应MySQL的表，n和MySQL中user表的id一一对应 user:n 操作： 都是H开头的命令 # 增 127.0.0.1:6379\u003e HMSET user:1 name zhangkai age 18 gender m OK 127.0.0.1:6379\u003e HMSET user:2 name wangkai age 18 gender m OK # 查 # 获取指定字段的值，相当于 select name from user where id=1; 127.0.0.1:6379\u003e HGET user:1 name \"zhangkai\" # 获取多个指定字段的值，相当于 select name,age from user where id=1; 127.0.0.1:6379\u003e HMGET user:1 name age 1) \"zhangkai\" 2) \"18\" # 获取所有键值对，相当于 select * from user; 127.0.0.1:6379\u003e HGETALL user:1 1) \"name\" 2) \"zhangkai\" 3) \"age\" 4) \"18\" 5) \"gender\" 6) \"m\" # 判断指定字段是否存在，存在返回1，否则返回0 127.0.0.1:6379\u003e HEXISTS user:1 name (integer) 1 # 返回key中所有字段的数量 127.0.0.1:6379\u003e HLEN user:1 (integer) 3 # 改 127.0.0.1:6379\u003e HINCRBY user:1 age 8 # 为整型字段的值加固定数字 127.0.0.1:6379\u003e HSET user:1 name zhangkai2 # 为指定字段重新赋值 ","date":"2024-04-14","objectID":"http://localhost:1313/posts/redis/:5:0","tags":null,"title":"redis安装","uri":"http://localhost:1313/posts/redis/"},{"categories":["deploy"],"content":"4集合# 集合的应用场景： 适用于各种需要求交集、并集、差集的场景，比如共同好友，共同关注的场景。 另外这里的集合也有数学上的集合特性，去重，交、并、差集的运算。 基础操作： # 增 127.0.0.1:6379\u003e SADD s1 a b c # 声明key并添加 a b c 三个元素 (integer) 3 127.0.0.1:6379\u003e SMEMBERS s1 # 返回 s1 中所有元素 1) \"c\" 2) \"b\" 3) \"a\" 127.0.0.1:6379\u003e SCARD s1 # 返回 s1 中元素的个数 (integer) 3 127.0.0.1:6379\u003e SRANDMEMBER s1 # 随机返回集合中的1个元素 \"a\" 127.0.0.1:6379\u003e SRANDMEMBER s1 \"a\" 127.0.0.1:6379\u003e SRANDMEMBER s1 \"c\" 127.0.0.1:6379\u003e SRANDMEMBER s1 \"b\" 127.0.0.1:6379\u003e SRANDMEMBER s1 2 # 随机返回指定个数的元素 1) \"b\" 2) \"c\" 127.0.0.1:6379\u003e SISMEMBER s1 a # 判断元素 a 是否存在 (integer) 1 # 删除 127.0.0.1:6379\u003e SPOP s1 # 随机删除一个元素，并将这个元素返回 \"c\" 127.0.0.1:6379\u003e SPOP s1 2 # 随机删除指定个数的元素，并将多个元素返回 1) \"d\" 2) \"a\" 127.0.0.1:6379\u003e DEL s1 # 删除集合 (integer) 1 # 移动 127.0.0.1:6379\u003e SADD s1 a b c # 将元素 a 从s1移动到s2中，如果s2不存在，就先创建再移动 (integer) 3 127.0.0.1:6379\u003e SMOVE s1 s2 a # 注意，一次只能移动一个，不支持多个，比如：SMOVE s1 s2 a b c (integer) 1 127.0.0.1:6379\u003e SMEMBERS s1 1) \"c\" 2) \"b\" 127.0.0.1:6379\u003e SMEMBERS s2 1) \"a\" 再来看集合的运算。我们来个示例，有个需求，现有个培训学校开设了Python和Linux两门课程，来学习的同学都有如下情况： 有的同学学习Linux 有的学习Python 还有的既学了Linux又学了Python 那现在问题来了，我们要对这些同学的情况做统计，比如找出两门课都报了的同学？ # 先把数据准备好 127.0.0.1:6379\u003e SADD python xiaoA xiaoB Huluwa xiaoC xiaoMaque (integer) 5 127.0.0.1:6379\u003e SADD linux xiaoC xiaoMaque xiaoD xiaoE xiaoDongbei (integer) 5 # 求交集，找出即学习了Python又学习了Linux的同学 127.0.0.1:6379\u003e SINTER python linux # 这俩集合谁在前谁在后没区别 1) \"xiaoC\" 2) \"xiaoMaque\" # 求交集，找出即学习了Python又学习了Linux的同学，并将结果保存到集合tmp中，tmp不存在则先创建 127.0.0.1:6379\u003e SINTERSTORE tmp python linux (integer) 2 127.0.0.1:6379\u003e SMEMBERS tmp 1) \"xiaoMaque\" 2) \"xiaoC\" # 求并集，找出学习两门课程的所有人 127.0.0.1:6379\u003e SUNION python linux 1) \"xiaoE\" 2) \"xiaoA\" 3) \"xiaoB\" 4) \"xiaoD\" 5) \"xiaoDongbei\" 6) \"xiaoMaque\" 7) \"xiaoC\" 8) \"Huluwa\" # 求并集，找出学习两门课程的所有人，并将结果保存到集合tmp中，tmp不存在则先创建 127.0.0.1:6379\u003e SUNIONSTORE tmp python linux (integer) 8 127.0.0.1:6379\u003e SMEMBERS tmp 1) \"xiaoE\" 2) \"xiaoA\" 3) \"xiaoB\" 4) \"xiaoD\" 5) \"xiaoDongbei\" 6) \"xiaoMaque\" 7) \"xiaoC\" 8) \"Huluwa\" # 求差集，找出只学习了Python（或者Linux）课程的人 127.0.0.1:6379\u003e SDIFF python linux # 只学习Python课程的人 1) \"xiaoA\" 2) \"xiaoB\" 3) \"Huluwa\" 127.0.0.1:6379\u003e SDIFFSTORE tmp python linux # 只学习Python课程的人,并将结果保存到集合tmp中，tmp不存在则先创建 (integer) 3 127.0.0.1:6379\u003e SMEMBERS tmp 1) \"xiaoA\" 2) \"xiaoB\" 3) \"Huluwa\" 127.0.0.1:6379\u003e SDIFF linux python # 只学习Linux课程的人 1) \"xiaoDongbei\" 2) \"xiaoE\" 3) \"xiaoD\" # # 只学习Linux课程的人,并将结果保存到集合tmp中，tmp不存在则先创建 127.0.0.1:6379\u003e SDIFFSTORE tmp linux python (integer) 3 127.0.0.1:6379\u003e SMEMBERS tmp 1) \"xiaoDongbei\" 2) \"xiaoE\" 3) \"xiaoD\" ","date":"2024-04-14","objectID":"http://localhost:1313/posts/redis/:6:0","tags":null,"title":"redis安装","uri":"http://localhost:1313/posts/redis/"},{"categories":["deploy"],"content":"5 有序集合zset# 有序集合在集合的基础上增加了排序功能，比如以点击数为条件进行排序。 有序集合的典型应用场景： 各种排行榜，音乐排行榜、热点新闻榜….. 在有序集合中，我们一般称其元素为成员，其成员对应的值为得分。 # 增加 127.0.0.1:6379\u003e ZADD top 0 xuwei 0 zhoujielun (integer) 2 # 查, withscores是可选参数，表示同时返回其成员和其得分 127.0.0.1:6379\u003e ZSCORE top xuwei # 返回top中，指定成员的分数，如果指定成员不存在则返回nil \"0\" 127.0.0.1:6379\u003e ZSCORE top zhangkai (nil) # 返回top中所有成员，默认以分数大小升序排序，分值相同按ASCII编码排序 127.0.0.1:6379\u003e ZRANGE top 0 -1 1) \"xuwei\" 2) \"zhoujielun\" 127.0.0.1:6379\u003e ZRANGE top 0 -1 WITHSCORES 1) \"xuwei\" 2) \"0\" 3) \"zhoujielun\" 4) \"0\" # 返回成员在有序集合中的索引下标，如果成员不存在返回nil 127.0.0.1:6379\u003e ZRANK top xuwei (integer) 0 127.0.0.1:6379\u003e ZRANK top zhangkai (nil) # 返回top中成员的数量 127.0.0.1:6379\u003e ZCARD top (integer) 2 # 返回top中所有成员，-inf表示第一个成员，+inf表示最后一个成员，结果默认以其分数的大小排序 127.0.0.1:6379\u003e ZRANGEBYSCORE top -inf +inf 1) \"xuwei\" 2) \"zhoujielun\" 127.0.0.1:6379\u003e ZRANGEBYSCORE top -inf +inf WITHSCORES 1) \"xuwei\" 2) \"0\" 3) \"zhoujielun\" 4) \"0\" # 返回top中所有成员，并且以索引从大到小排序 127.0.0.1:6379\u003e ZREVRANGE top 0 -1 1) \"zhoujielun\" 2) \"xuwei\" 127.0.0.1:6379\u003e ZREVRANGE top 0 -1 WITHSCORES 1) \"zhoujielun\" 2) \"0\" 3) \"xuwei\" 4) \"0\" # 返回top中 0 \u003c= index \u003c= 2 索引范围内的成员，不在范围内返回空 127.0.0.1:6379\u003e ZREVRANGE top 0 2 1) \"zhoujielun\" 2) \"xuwei\" 127.0.0.1:6379\u003e ZREVRANGE top 0 2 WITHSCORES 1) \"zhoujielun\" 2) \"0\" 3) \"xuwei\" 4) \"0\" 127.0.0.1:6379\u003e ZREVRANGE top 3 5 WITHSCORES (empty list or set) # 返回top中分数在 20 \u003c= 分数 \u003c= 200 这个范围内的成员的数量 127.0.0.1:6379\u003e ZADD top 20 xuwei 80 zhoujielun 100 daolang 120 zhaolei # 先搞个数据 127.0.0.1:6379\u003e ZCOUNT top 20 200 (integer) 4 # 返回top中分数在 20 \u003c= 分数 \u003c= 200 这个范围内的成员 127.0.0.1:6379\u003e ZRANGEBYSCORE top 20 200 1) \"xuwei\" 2) \"zhoujielun\" 3) \"daolang\" 4) \"zhaolei\" 127.0.0.1:6379\u003e ZRANGEBYSCORE top 20 200 WITHSCORES 1) \"xuwei\" 2) \"20\" 3) \"zhoujielun\" 4) \"80\" 5) \"daolang\" 6) \"100\" 7) \"zhaolei\" 8) \"120\" # 返回top中分数范围在 100 \u003c= 的 \u003c= 20 范围内的成员，并以的的大小降序排序 127.0.0.1:6379\u003e ZREVRANGEBYSCORE top 100 20 1) \"daolang\" 2) \"zhoujielun\" 3) \"xuwei\" 127.0.0.1:6379\u003e ZREVRANGEBYSCORE top 100 20 WITHSCORES 1) \"daolang\" 2) \"100\" 3) \"zhoujielun\" 4) \"80\" 5) \"xuwei\" 6) \"20\" # 改 # 为指定成员重新赋值 127.0.0.1:6379\u003e ZADD top 30 xuwei (integer) 0 # 为指定成员增加指定分数，并返回增加后的分数 127.0.0.1:6379\u003e ZINCRBY top 10 xuwei \"40\" # 删除 # 删除分数在指定范围内的成员，并返回删除成员的数量 127.0.0.1:6379\u003e ZREMRANGEBYSCORE top 80 100 (integer) 2 # 删除top中指定索引范围内 0 \u003c= index \u003c= 1 的成员 127.0.0.1:6379\u003e ZREMRANGEBYRANK top 0 1 (integer) 2 # 删除top中一个或者多个成员，返回实际删除的个数，没有找到key返回0 127.0.0.1:6379\u003e ZREMRANGEBYRANK top 0 1 (integer) 2 127.0.0.1:6379\u003e DEL top (integer) 1 来个音乐排行榜的示例： # 创建初始的音乐排行榜，初始每首歌播放量都是0 ZADD top 0 aiqing 0 guxiang 0 lanlianhua 0 shiguang # 模拟每首歌的播放量 ZINCRBY top 123 aiqing ZINCRBY top 223 guxiang ZINCRBY top 203 lanlianhua ZINCRBY top 103 shiguang # 返回播放量前三名的歌名 127.0.0.1:6379\u003e ZREVRANGE top 0 2 WITHSCORES 1) \"guxiang\" 2) \"223\" 3) \"lanlianhua\" 4) \"203\" 5) \"aiqing\" 6) \"123\" 6：redis-发布订阅 消息队列 Redis中的发布订阅模式，类似于RabbitMQ中的主题订阅模式。 在发布订阅模式中，有三个角色： 生产者，它同样是一个redis客户端，负责生产消息。可以有一个或者多个生产者往一个或者多个频道中发布消息。 channel，频道，类似于主题，接收来自于生产者产生的消息，为不同的消息打个标签，可以有多个频道。它维护在redis的server中。 消费者，也是一个Redis客户端，可以订阅感兴趣的消息，也就是可以(一个或者多个)订阅不同频道的消息。 如上图，有三个生产者负责生产消息，并且发布到指定的频道中，消费者可以选择订阅一个或者多个频道中的消息。 操作： # 首先要现有多个消费者订阅不同的频道，订阅一个、多个、模糊匹配；你可以起三个终端来分别订阅\rSUBSCRIBE fm103\rSUBSCRIBE fm103 fm104\rPSUBSCRIBE fm*\r# 然后有不同的生产者往指定的频道生产消息，可以用三个终端来发布消息，也可以用一个也行，分别向不同的频道发布消息\rPUBLISH fm103 \"fm103.9 it's my radio, messages1\"\rPUBLISH fm103 \"fm103.9 it's my radio, messages2\"\rPUBLISH fm103 \"fm103.9 it's my radio, messages3\"\rPUBLISH fm104 \"fm104.9 it's my radio, messages1\"\rPUBLISH fm104 \"fm104.9 it's my radio, messages2\"\rPUBLISH fm104 \"fm104.9 it's my radio, messages3\"\rPUBLISH fm105 \"fm105.9 it's my radio, messages1\"\rPUBLISH fm105 \"fm105.9 it's my radio, messages2\"\rPUBLISH fm105 \"fm105.9 it's my radio, messages3\" 上述几个消费者就能根据自己的规则接收到不同的频道的消息，其效果如下图 这里需要注意的是，消费者不会接收频道的历史消息，只会接受订阅后产生的消息。 其他操作： # 取消订阅频道 UNSUBSCRIBE # 不跟频道号则取消订阅所有频道 UNSUBSCRIBE fm103 # 取消订阅fm103频道 UNSUBSCRIBE fm103 fm104 # 取消订阅多个频道 UNSUBSCRIBE fm* # 取消订阅以fm开头的频道 Redis发布订阅优点： Redis的发布订阅支持多个生产者/消费者，同时生产消费消息，优点就是非常简洁，因为它的实现原理就是单纯地为生产者、消费者建立「数据转发通道」，把符合规则的数据，从一端转发到另一端。 缺点: 发布订阅模式是\"发后既忘\"的","date":"2024-04-14","objectID":"http://localhost:1313/posts/redis/:7:0","tags":null,"title":"redis安装","uri":"http://localhost:1313/posts/redis/"},{"categories":["web"],"content":"概要 vue3-cookie 使用 cookies vue3中需要使用cookies存储用户信息，可以使用vue3-cookies 安装 npm install vue3-cookies 全局挂载 # main.js import App from './App.vue' import VueCookies from \"vue3-cookies\"; const app = createApp(App) app.use(VueCookies) 基本的使用 # xxxx.js import {useCookies} from 'vue3-cookies' const {cookies} = useCookies() cookies.set(\"info\", JSON.stringify(info), 10) // 设置键值对 cookies.get(\"info\") //获取键值对，可以直接获取json对象，不需要通过parse进行解析 pinia import {ref, computed} from 'vue' import {defineStore} from 'pinia' import {useCookies} from 'vue3-cookies' const {cookies} = useCookies() // 导入vue3使用cookies export const userInfoStore = defineStore('counter', () =\u003e { var userStr = ref(cookies.get(\"info\")) const userDict = computed(() =\u003e JSON.parse(userStr.value)) function doSave(info) { cookies.set(\"info\", JSON.stringify(info), 10) // 单位分钟 userStr.value = JSON.stringify(info) } return {userDict, doSave} }) 导航守卫 router.beforeEach(function (to, from, next) { // 1 登录页面，不需要校验直接过 if (to.name === \"login\") { next() return; } const store = userInfoStore() console.log(\"store\",store) if (!store.userId) { next({name: \"login\"}) }else{ next() } }) element-ui 配置 npm install element- import ElementPlus from 'element-plus' import 'element-plus/dist/index.css' app.use(ElementPlus) //全局注册element-plus 登录组件 模板部分 \u003ctemplate\u003e \u003c!-- \u003cv-form-designer\u003e\u003c/v-form-designer\u003e--\u003e \u003cdiv class=\"box\" v-if=\"!isRegister\"\u003e \u003ch1 style=\"text-align: center\"\u003e用户登录\u003c/h1\u003e \u003cel-form :model=\"form\" label-width=\"auto\" style=\"max-width: 600px\" label-position=\"top\" :rules=\"formRules\" ref=\"formRef\"\u003e \u003cel-form-item label=\"用户名\" :error=\"formError.username\" prop=\"username\"\u003e \u003cel-input v-model=\"form.username\" style=\"width: 240px\" placeholder=\"用户名\"/\u003e \u003c/el-form-item\u003e \u003cel-form-item label=\"密码\" :error=\"formError.password\" prop=\"password\"\u003e \u003cel-input v-model=\"form.password\" style=\"width: 240px\" placeholder=\"请输入密码\"/\u003e \u003c/el-form-item\u003e \u003c/el-form\u003e \u003cel-form-item\u003e \u003cel-button type=\"primary\" @click=\"doSubmit\"\u003e登录\u003c/el-button\u003e \u003cspan style=\"margin-left: 10px\" @click=\"isRegister=true\"\u003e没有账号?点击注册\u003c/span\u003e \u003c/el-form-item\u003e \u003c/div\u003e \u003cdiv class=\"box\" v-if=\"isRegister\"\u003e \u003ch1 style=\"text-align: center\"\u003e用户注册\u003c/h1\u003e \u003cel-form :model=\"registerForm\" label-width=\"auto\" style=\"max-width: 600px\" label-position=\"top\" :rules=\"registerRules\" ref=\"formRef\"\u003e \u003cel-form-item label=\"上传头像\" prop=\"avator\"\u003e \u003cel-upload class=\"avatar-uploader\" action=\"http://127.0.0.1:8000/upload/\" :show-file-list=\"false\" :on-success=\"handleAvatarSuccess\" :before-upload=\"beforeAvatarUpload\" \u003e \u003cimg v-if=\"imageUrl\" :src=\"imageUrl\" class=\"avatar\" style=\"width: 150px;height: 120px\" /\u003e \u003cimg v-if=\"!imageUrl\" :src=\"static_url + `/media/avatar/default.jpg`\" class=\"avatar\" style=\"width: 150px;height: 120px\" /\u003e \u003cel-icon v-else class=\"avatar-uploader-icon\"\u003e\u003cPlus /\u003e\u003c/el-icon\u003e \u003c/el-upload\u003e \u003c/el-form-item\u003e \u003cel-form-item label=\"昵称\" :error=\"RegisterError.nickname\" prop=\"nickname\"\u003e \u003cel-input v-model=\"registerForm.nickname\" style=\"width: 240px\" placeholder=\"昵称\"/\u003e \u003c/el-form-item\u003e \u003cel-form-item label=\"用户名\" :error=\"RegisterError.username\" prop=\"username\"\u003e \u003cel-input v-model=\"registerForm.username\" style=\"width: 240px\" placeholder=\"用户名\"/\u003e \u003c/el-form-item\u003e \u003cel-form-item label=\"密码\" :error=\"RegisterError.password\" prop=\"password\"\u003e \u003cel-input v-model=\"registerForm.password\" style=\"width: 240px\" placeholder=\"请输入密码\"/\u003e \u003c/el-form-item\u003e \u003c!-- \u003cel-form-item label=\"性别\"\u003e--\u003e \u003c!-- \u003cel-select v-model=\"registerForm.sex\" placeholder=\"请选择性别\"\u003e--\u003e \u003c!-- \u003cel-option label=\"保密\" value=\"2\"/\u003e--\u003e \u003c!-- \u003cel-option label=\"男\" value=\"1\"/\u003e--\u003e \u003c!-- \u003cel-option label=\"女\" value=\"0\"/\u003e--\u003e \u003c!-- \u003c/el-select\u003e--\u003e \u003c!-- \u003c/el-form-item\u003e--\u003e \u003c/el-form\u003e \u003cel-form-item\u003e \u003cel-button type=\"primary\" @click=\"doRegister\"\u003e注册\u003c/el-button\u003e \u003cspan style=\"margin-left: 10px\" @click=\"isRegister=false;registerForm.avator='/media/avator/default.jpg'\"\u003e立即登录\u003c/span\u003e \u003c/el-form-item\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript setup\u003e import {ref} from \"vue\"; import {useRoute, useRouter} from \"vue-router\" import {userInfoStore} from \"@/stores/counter.js\"; import _axios from \"@/plugins/axios.js\"; import {ElMessag","date":"2024-01-28","objectID":"http://localhost:1313/posts/vue/:0:0","tags":null,"title":"Vue学习","uri":"http://localhost:1313/posts/vue/"},{"categories":null,"content":"关于redis各平台的安装","date":"2023-10-15","objectID":"http://localhost:1313/posts/first_post/","tags":null,"title":"关于博客","uri":"http://localhost:1313/posts/first_post/"},{"categories":null,"content":"第一篇文章 自从开始学计算机，我就一直对于知识点的掌握虚浮经常需要翻阅文献资料和笔记,故建此博客，以供自己查询方便，顺便熟悉一个非常牛的静态页面生成器-HUGO ","date":"2023-10-15","objectID":"http://localhost:1313/posts/first_post/:0:0","tags":null,"title":"关于博客","uri":"http://localhost:1313/posts/first_post/"},{"categories":["default"],"content":"git 命令整理 ","date":"2023-10-11","objectID":"http://localhost:1313/posts/git/:0:0","tags":null,"title":"git命令整理","uri":"http://localhost:1313/posts/git/"},{"categories":["default"],"content":"基础命令 进入待管理文件夹 git init // 初始化让git管理当前文件夹 git status // 检测当前文件的状态 比如是否有修改，是否未管理 git add // 指定某个文件让git管理它 // 红色文件(工作区)表示新增的或者修改的文件 绿色(暂存区)文件表示已经被管理起来但是没有被生成版本的文件 git reset HEAD 文件名 // 从暂存区回到工作区，相当于撤销git add命令的提交 git commit -m \"版本号\" // 生成版本 (版本库) ","date":"2023-10-11","objectID":"http://localhost:1313/posts/git/:1:0","tags":null,"title":"git命令整理","uri":"http://localhost:1313/posts/git/"},{"categories":["default"],"content":"回滚相关 回滚之前的版本 git log // 查看所有版本记录 git reset --hard 版本哈希号 // 回滚后 git log 将无法查看当前版本之后的版本了 回滚当前版本之后的版本 git reflog // 查看提交记录 cd6d6d8 (HEAD -\u003e master) HEAD@{0}: reset: moving to cd6d6d82ecf420cf72a333572bc41b1360187541 163df79 HEAD@{1}: commit: v2 cd6d6d8 (HEAD -\u003e master) HEAD@{2}: commit (initial): v1 git reset --hard 163df79 // 再次回到之前的版本 ","date":"2023-10-11","objectID":"http://localhost:1313/posts/git/:2:0","tags":null,"title":"git命令整理","uri":"http://localhost:1313/posts/git/"},{"categories":["default"],"content":"分支相关 git 默认主干线 master ,分支之间的代码是隔离的，单独提交各自的版本即可 查看分支 git branch // 查看当前所处分支以及其它分支 创建分支 git branch dev // 创建一个新的分支名未dev 切换分支 git checkout dev // 切换到dev分支 删除分支 git branch -d dev // 删除dev 分支 合并分支（可能会产生冲突,需要找到冲突，手动修改） git marge dev // 把bug分支合并到主分支 ","date":"2023-10-11","objectID":"http://localhost:1313/posts/git/:3:0","tags":null,"title":"git命令整理","uri":"http://localhost:1313/posts/git/"},{"categories":["default"],"content":"代码推送相关 绑定仓库地址 git remote add origin \u003c仓库地址名\u003e 推送仓库 git push -(u) origin master ","date":"2023-10-11","objectID":"http://localhost:1313/posts/git/:4:0","tags":null,"title":"git命令整理","uri":"http://localhost:1313/posts/git/"},{"categories":["default"],"content":"从仓库拉代码 下载代码 git clone \u003c代码仓库地址\u003e 更新本地代码 git pull origin master //更新代码 ","date":"2023-10-11","objectID":"http://localhost:1313/posts/git/:5:0","tags":null,"title":"git命令整理","uri":"http://localhost:1313/posts/git/"}]